#include "ExampleController.h" namespace Controllers { namespace Example { ExampleController::ExampleController() { } } // namespace Example } // namespace Controllers#pragma once #include "./../../Server/WebSocket/SocketAction.h" #include <memory> namespace Controllers { namespace Example { typedef SocAction Server::WebSocket::SocketAction; class ExampleController { public: ExampleController(); SocAction getEchoAction(); std::shared_ptr<SocAction> action; }; } // namespace Example } // namespace Controllers#include "LogsController.h" namespace Controllers { namespace Logs { LogsController::LogsController(const std::string& folder, const std::string& logExtension) { this->logsReader = std::make_shared<Services::LogsReader>(folder, logExtension); } std::shared_ptr<Server::Action> LogsController::getLogsFiles() { if (this->logsFilesAction == nullptr) { this->logsFilesAction = std::make_shared<LogsFilesAction>(this->logsReader); } return this->logsFilesAction; } std::shared_ptr<Server::Action> LogsController::getLogsMsgs() { if (this->logsMsgsAction == nullptr) { this->logsMsgsAction = std::make_shared<LogsMsgsAction>(); } return this->logsMsgsAction; } } // namespace Logs } // namespace Controllers#pragma once #include "./../../Common/Config.h" #include "./../../Server/Action.h" #include "./../../Services/LogsReader.h" #include "LogsFilesAction.h" #include "LogsMsgsAction.h" #include <string> namespace Controllers { namespace Logs { class LogsController { public: LogsController(const std::string&, const std::string&); std::shared_ptr<Server::Action> getLogsFiles(); std::shared_ptr<Server::Action> getLogsMsgs(); protected: std::shared_ptr<Services::LogsReader> logsReader = nullptr; std::shared_ptr<Server::Action> logsFilesAction = nullptr; std::shared_ptr<Server::Action> logsMsgsAction = nullptr; }; } // namespace Logs } // namespace Controllers#include "LogsFilesAction.h" namespace Controllers { namespace Logs { LogsFilesAction::LogsFilesAction(std::shared_ptr<Services::LogsReader> ptr) : reader(std::move(ptr)) {} std::shared_ptr<Server::Response> LogsFilesAction::run(const Server::Request&) { std::shared_ptr<Server::Response> response = std::make_shared<Server::Response>(); auto files = this->reader->getLogsFiles(); nlohmann::json j; for (auto& f : files) { j.push_back(f); } response->jsonResponse(j.dump()); return response; } } // namespace Logs } // namespace Controllers #pragma once #include "./../../Server/Action.h" #include "./../../Server/Request.h" #include "./../../Server/Response.h" #include "./../../Services/LogsReader.h" #include "./../../json/json.hpp" namespace Controllers { namespace Logs { class LogsFilesAction : public Server::Action { public: LogsFilesAction(std::shared_ptr<Services::LogsReader> reader); std::shared_ptr<Server::Response> run(const Server::Request&) override; protected: std::shared_ptr<Services::LogsReader> reader; }; } // namespace Logs } // namespace Controllers#include "LogsMsgsAction.h" #include "../../Common/Config.h" #include "../../Services/LogFile.h" namespace Controllers { namespace Logs { std::shared_ptr<Server::Response> LogsMsgsAction::run(const Server::Request& req) { auto file = std::string(req.getParam("file")); auto c = Common::Config::getInstance(); if (file.substr(0, 1) == "/") { file = file.substr(1); } file = c->logsFolder + file; auto logFile = Services::LogFile(file); if (logFile.isValidLogFile) { std::shared_ptr<Server::Response> response = std::make_shared<Server::Response>(); auto j = nlohmann::json::array(); auto msgs = logFile.getMsgs(); for (auto& msg : msgs) { j.push_back(msg); } response->jsonResponse(j.dump()); return response; } return nullptr; // 404 } } // namespace Logs } // namespace Controllers #pragma once #include "../../Server/Action.h" namespace Controllers { namespace Logs { class LogsMsgsAction : public Server::Action { std::shared_ptr<Server::Response> run(const Server::Request&) override; }; } // namespace Logs } // namespace Controllers#include "GetLogsLevelsAction.h" #include "../../Common/Config.h" namespace Controllers { namespace LogsLevels { std::shared_ptr<Server::Response> GetLogsLevelsAction::run(const Server::Request& req) { std::shared_ptr<Server::Response> response = std::make_shared<Server::Response>(); auto levels = Common::Config::getInstance()->logLevels; auto j = nlohmann::json::array(); for (auto& level : levels) { j.push_back(*level); } response->jsonResponse(j.dump()); return response; } } // namespace LogsLevels } // namespace Controllers#pragma once #include "../../Server/Action.h" #include "../../json/json.hpp" namespace Controllers { namespace LogsLevels { class GetLogsLevelsAction : public Server::Action { std::shared_ptr<Server::Response> run(const Server::Request&) override; }; } // namespace LogsLevels } // namespace Controllers#include "LogsLevelsController.h" namespace Controllers { namespace LogsLevels { std::shared_ptr<Server::Action> LogsLevelsController::getLogLevels() { auto action = std::make_shared<GetLogsLevelsAction>(); return action; } } // namespace LogsLevels } // namespace Controllers#pragma once #include "../../Server/Action.h" #include "./GetLogsLevelsAction.h" #include <memory> namespace Controllers { namespace LogsLevels { class LogsLevelsController { public: std::shared_ptr<Server::Action> getLogLevels(); }; } // namespace LogsLevels } // namespace Controllers#include "MemoryController.h" namespace Controllers { namespace Memory { MemoryController::MemoryController() { } std::shared_ptr<MemoryInfoCurrent> MemoryController::memoryDataAction() { auto action = std::make_shared<MemoryInfoCurrent>(); return action; } } // namespace Memory } // namespace Controllers #pragma once #include "../../Server/Server.h" #include "./MemoryInfoCurrent.h" namespace Controllers { namespace Memory { class MemoryController { public: MemoryController(); std::shared_ptr<MemoryInfoCurrent> memoryDataAction(); }; } // namespace Memory } // namespace Controllers#include "MemoryInfoCurrent.h" namespace Controllers { namespace Memory { std::shared_ptr<Server::Response> MemoryInfoCurrent::run(const Server::Request& req) { auto response = std::make_shared<Server::Response>(); Services::MemoryInfo memInfo; nlohmann::json j = memInfo; response->jsonResponse(j.dump()); return response; } } // namespace Memory } // namespace Controllers#pragma once #include "./../../Server/Action.h" #include "./../../Server/Request.h" #include "./../../Server/Response.h" #include "./../../Services/MemoryInfo.h" #include "./../../json/json.hpp" namespace Controllers { namespace Memory { class MemoryInfoCurrent : public Server::Action { public: std::shared_ptr<Server::Response> run(const Server::Request&) override; }; } // namespace Memory } // namespace Controllers#include "Action.h" namespace Server { Action::~Action() { } Action::Action() { } } // namespace Server#pragma once #include "Request.h" #include "Response.h" #include <memory> namespace Server { class Action { public: Action(); ~Action(); virtual std::shared_ptr<Response> run(const Request&) = 0; }; } // namespace Server #pragma once #include <map> typedef std::map<std::string, std::string> RouteParams; namespace Server { enum class HTTP_METHOD { GET, POST, OPTIONS, PUT, DELETE, HEAD, CONNECT, PATCH, TRACE }; }#include "Request.h" #include "Server.h" #include "common.h" #include <event2/keyvalq_struct.h> namespace Server { Request::Request(evhttp_request* req, const RouteParams& params) : _params(params) { this->_req = req; } const char* Request::getUri() const { return evhttp_request_get_uri(this->_req); } const char* Request::getBody() const { auto buffer = evhttp_request_get_input_buffer(this->_req); auto len = evbuffer_get_length(buffer); char* data = (char*)malloc(len); evbuffer_copyout(buffer, data, len); return data; } std::map<std::string, std::string> Request::getHeaders() const { auto headers = evhttp_request_get_input_headers(this->_req); auto tqh = headers->tqh_first; std::map<std::string, std::string> headersMap; while (tqh != nullptr) { headersMap.insert(std::make_pair(std::string(tqh->key), std::string(tqh->value))); tqh = tqh->next.tqe_next; } return headersMap; }; const char* Request::getHeader(const std::string& headerKey) const { auto headers = evhttp_request_get_input_headers(this->_req); auto header = evhttp_find_header(headers, headerKey.c_str()); return header; } HTTP_METHOD Request::getMethod() const { auto cmd = evhttp_request_get_command(this->_req); return Server::convertEvCmd(cmd); } const char* Request::getParam(const std::string& param) const { auto it = this->_params.find(param); if (it != this->_params.end()) { return it->second.c_str(); } return nullptr; } const char* Request::getQueryParam(const std::string& qName) const { auto uri = this->getUri(); struct evkeyvalq query; evhttp_parse_query_str(uri, &query); return evhttp_find_header(&query, qName.c_str()); } evhttp_request* Request::getReq() const { return this->_req; } } // namespace Server#pragma once #include "common.h" #include "map" #include "string" #include <evhttp.h> namespace Server { class Request { public: Request(evhttp_request* reg, const RouteParams&); HTTP_METHOD getMethod() const; const char* getParam(const std::string&) const; const char* getHeader(const std::string&) const; const char* getQueryParam(const std::string&) const; const char* getBody() const; const char* getUri() const; std::map<std::string, std::string> getHeaders() const; evhttp_request* getReq() const; protected: struct evhttp_request* _req; RouteParams _params; }; } // namespace Server #include "Response.h" namespace Server { Response::Response() { this->responseCode(Response::DEFAULT_HTTP_CODE); this->type("text/html"); } Response* Response::responseCode(const short& code) { this->_responseCode = code; return this; } short Response::responseCode() { return this->_responseCode; } Response* Response::type(const std::string& type) { this->headers[Response::CONTENT_TYPE_HEADER] = type + "; charset=utf-8"; return this; } std::string Response::type() { return this->headers[Response::CONTENT_TYPE_HEADER]; } std::string Response::header(const std::string& header) { return this->headers[header]; } Response* Response::header(const std::string& header, const std::string& val) { this->headers[header] = val; return this; } Response* Response::body(const std::string& body) { this->_body = body; return this; } Response* Response::jsonResponse(const std::string& json) { this->responseCode(200) ->type("application/Json") ->body(json); return this; } std::string Response::body() { return this->_body; } } // namespace Server#pragma once #include <map> #include <memory> #include <string> namespace Server { class Response { public: const std::string CONTENT_TYPE_HEADER = "Content-Type"; const short DEFAULT_HTTP_CODE = 200; std::map<std::string, std::string> headers; Response(); Response* responseCode(const short& code); short responseCode(); Response* type(const std::string& type); std::string type(); Response* header(const std::string& header, const std::string& val); std::string header(const std::string& header); Response* body(const std::string&); std::string body(); Response* jsonResponse(const std::string&); protected: short _responseCode = Response::DEFAULT_HTTP_CODE; std::string _body; }; } // namespace Server#include "Route.h" #include "../Common/StrTemplate.h" #include <iostream> namespace Server { Route::Route(const std::string& str, std::shared_ptr<Action> action, const HTTP_METHOD& method) : _method(method) { this->_sourceStr = str; this->action = std::move(action); this->_setRegex(); } void Route::_setRegex() { std::string s = this->_sourceStr; if (s.back() == '/') { s = s.substr(0, s.size() - 1); } auto strTemplate = Common::StrTemplate(this->_sourceStr); this->_regex = strTemplate.regular; this->_params = strTemplate.params; } RouteParams Route::exec(const std::string& path) { std::smatch match; RouteParams params; if (std::regex_match(path, match, this->_regex)) { for (int i = 1; i < match.size(); i++) { params.insert(std::make_pair(this->_params[i - 1], match[i].str())); } } return params; } bool Route::check(std::string path, const HTTP_METHOD& method) { if (method != this->_method) { return false; } if (path.back() == '/') { path = path.substr(0, path.size() - 1); } return std::regex_match(path, this->_regex); } } // namespace Server#pragma once #include "Action.h" #include "common.h" #include <iostream> #include <map> #include <regex> #include <string> namespace Server { class Route { public: Route(const std::string&, std::shared_ptr<Action>, const HTTP_METHOD&); std::shared_ptr<Server::Action> action; RouteParams exec(const std::string&); bool check(std::string, const HTTP_METHOD&); protected: void _setRegex(); std::string _sourceStr; std::regex _regex; std::vector<std::string> _params; HTTP_METHOD _method; }; } // namespace Server#include "Server.h" #include "./../Common/Base64.h" #include "./../SHA1/sha1.hpp" #include "Request.h" #include "Route.h" #include "WebSocket/Frame.h" #include "WebSocket/FrameFactory.h" #include "WebSocket/FrameReader.h" #include "WebSocket/FrameWriter.h" #include "WebSocket/SocketConnection.h" #include <bitset> #include <cstring> #include <event2/buffer.h> #include <event2/bufferevent.h> #include <event2/util.h> #include <fstream> #include <iostream> #include <sys/stat.h> #include <typeinfo> namespace Server { Server::Server() {} /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Start server LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param port */ void Server::start(unsigned port) { auto base = event_base_new(); if (base == nullptr) { fprintf(stderr, "Couldn't create an event_base: exiting\n"); return; } auto http = evhttp_new(base); if (http == nullptr) { fprintf(stderr, "Couldn't create an event_http\n"); return; } auto socket = evhttp_bind_socket_with_handle(http, "0.0.0.0", port); if (socket == nullptr) { fprintf(stderr, "Couldn't bind socket"); return; } std::cout << "Server start at " + std::to_string(port) << std::endl; evhttp_set_gencb(http, [](evhttp_request* req, void* arg) -> void { auto server = static_cast<Server*>(arg); auto uri = evhttp_request_get_evhttp_uri(req); auto uriPath = evhttp_uri_get_path(uri); std::shared_ptr<Response> response = nullptr; if (server->isReturnHome(uriPath)) { response = server->getHomePage(); } RouteParams params; auto request = Request(req, params); std::string keyResponse = std::string(request.getHeader("Sec-WebSocket-Key")) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"; char base64[SHA1_BASE64_SIZE]; sha1(keyResponse.c_str()).finalize().print_base64(base64); response = std::make_shared<Response>(); response->header("Sec-WebSocket-Accept", base64) ->header("Upgrade", "websocket") ->header("Connection", "Upgrade") ->responseCode(101); server->sendResponse(req, response); auto connection = evhttp_request_get_connection(req); auto connectBuffer = evhttp_connection_get_bufferevent(connection); bufferevent_setcb(connectBuffer, [](struct bufferevent* bev, void* ctx) -> void { std::cout << "Get" << std::endl; WebSocket::SocketConnection* conn = (WebSocket::SocketConnection*)ctx; auto reader = conn->getFrameReader(); size_t len = evbuffer_get_length(bufferevent_get_input(bev)); auto buf = new char[len]; auto readn = bufferevent_read(bev, buf, len); for (unsigned i = 0; i < len; i++) { reader->read(buf[i]); } if (reader->isEndRead()) { std::cout << "End" << std::endl; auto frameData = reader->getFrameData(); auto writer = WebSocket::FrameWriter(); if (frameData.opcode == WebSocket::Frame::OPCODE_CLOSE) { if (conn->state != WebSocket::SocketConnection::CLOSING) { writer.setFrame(WebSocket::FrameFactory::closeFrame()); auto output = writer.output(); bufferevent_write(bev, output.c_str(), output.size()); } bufferevent_free(bev); conn->close(); delete conn; } else { writer.setFrame(WebSocket::FrameFactory::closeFrame()); auto output = writer.output(); bufferevent_write(bev, output.c_str(), output.size()); reader->clear(); conn->state = WebSocket::SocketConnection::CLOSING; // bufferevent_setwatermark(bev, EV_READ, 0, 0); // bufferevent_disable(bev); // bufferevent_free(bev); // conn->close(); } } }, nullptr, nullptr, new WebSocket::SocketConnection(connection)); bufferevent_setwatermark(connectBuffer, EV_READ, 1, 1); bufferevent_setwatermark(connectBuffer, EV_WRITE, 0, 0); bufferevent_enable(connectBuffer, EV_READ); return; if (response == nullptr) { auto httpMethod = Server::convertEvCmd(evhttp_request_get_command(req)); for (auto r : server->_routes) { if (r.check(uriPath, httpMethod)) { auto params = r.exec(evhttp_uri_get_path(uri)); auto request = Request(req, params); response = r.action->run(request); break; } } } if (response == nullptr) { std::string fileName; if (server->staticRouteFileName(uriPath, fileName)) { response = server->getFileResponse(fileName); } else { response = server->get404Response(); } } server->sendResponse(req, response); }, this); event_base_dispatch(base); } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Set route LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param path can have params like. Ex: :test LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param action LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param method */ void Server::route(const std::string& path, std::shared_ptr<Action> action, const HTTP_METHOD& method) { Route r(path, std::move(action), method); this->_routes.push_back(r); } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Set virtual path for folder LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param path LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param folder */ void Server::staticRoute(const std::string& path, const std::string& folder) { this->_staticRoutes.insert(std::make_pair(path, folder)); } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Set webcoket route LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param path LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param action */ void Server::websocketRoute(const std::string& path, std::shared_ptr<WebSocket::SocketAction> action) { WebSocket::SocketRoute r(path, action); this->_socketRoutes.push_back(r); PW } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Set content type for extension of file LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param extension LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param contentTypeW */ void Server::addExtensionType(const std::string& extension, const std::string& contentType) { this->_extensions.insert(std::make_pair(extension, contentType)); } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Check is can return by path LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param virtualPath LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param filePath LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return */ bool Server::staticRouteFileName(const std::string& virtualPath, std::string& filePath) { for (const auto& staticRoute : this->_staticRoutes) { std::smatch m; std::regex e("^" + staticRoute.first + "(.+)$"); auto result = std::regex_search(virtualPath, m, e); if (result) { struct stat buffer; if (stat((staticRoute.second + m.str(1)).c_str(), &buffer) == 0) { filePath = staticRoute.second + m.str(1); return true; } } } return false; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Response for output content of file LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param file path to file LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return */ std::shared_ptr<Response> Server::getFileResponse(const std::string& file) { auto response = std::make_shared<Response>(); std::ifstream ifs(file); auto content = std::string(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>()); response->body(content) ->responseCode(200); auto dotKey = file.find_last_of('.'); if (dotKey != -1 && dotKey != file.length() - 1) { auto extIt = this->_extensions.find(file.substr(dotKey + 1)); if (extIt != this->_extensions.end()) { response->type(extIt->second); } } return response; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log 404 Response LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return */ std::shared_ptr<Response> Server::get404Response() { auto response = std::make_shared<Response>(); response->body("404 mother fucker") ->responseCode(404); return response; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log On what routes call home response LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param routes */ void Server::homeOn(const std::vector<std::string>& routes) { this->homeRoutes = routes; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Send response on request LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param req LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param response */ void Server::sendResponse(evhttp_request* req, std::shared_ptr<Response> response) { auto buffer = evbuffer_new(); auto b = response->body(); auto reqHeaders = evhttp_request_get_output_headers(req); response->header("Access-Control-Allow-Origin", "*"); for (const auto& pair : response->headers) { evhttp_add_header(reqHeaders, pair.first.c_str(), pair.second.c_str()); } evbuffer_add(buffer, b.c_str(), b.size()); evhttp_send_reply(req, response->responseCode(), nullptr, buffer); evbuffer_free(buffer); } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Set path to file home page LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param filePath */ void Server::fileHomePage(const std::string& filePath) { this->fileHomePagePath = filePath; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Response of home page LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return */ std::shared_ptr<Response> Server::getHomePage() { if (!this->fileHomePagePath.empty()) { return this->getFileResponse(this->fileHomePagePath); } else { return nullptr; } } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Convert evhttp_cmd_type to HTTP_METHOD LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param cmd LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return HTTP_METHOD eq cmd */ HTTP_METHOD Server::convertEvCmd(const evhttp_cmd_type& cmd) { switch (cmd) { case EVHTTP_REQ_GET: return HTTP_METHOD::GET; case EVHTTP_REQ_POST: return HTTP_METHOD::POST; case EVHTTP_REQ_DELETE: return HTTP_METHOD::DELETE; case EVHTTP_REQ_PUT: return HTTP_METHOD::PUT; case EVHTTP_REQ_OPTIONS: return HTTP_METHOD::OPTIONS; case EVHTTP_REQ_HEAD: return HTTP_METHOD::HEAD; case EVHTTP_REQ_CONNECT: return HTTP_METHOD::CONNECT; case EVHTTP_REQ_PATCH: return HTTP_METHOD::PATCH; case EVHTTP_REQ_TRACE: return HTTP_METHOD::TRACE; } return HTTP_METHOD::GET; } /bin /boot /cdrom /core /data /dev /etc /home /initrd.img /initrd.img.old /lib /lib32 /lib64 /lost+found /media /mnt /opt /proc /root /run /sbin /snap /srv /sys /tmp /usr /var /vmlinuz /vmlinuz.old LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log Is return home response LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @param path LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log @return */ bool Server::isReturnHome(const std::string& path) { if (path == "/") { return true; } for (const auto& route : this->homeRoutes) { if (route == path) { return true; } } return false; } } // namespace Server#pragma once #include <event2/buffer.h> #include <event2/event.h> #include <event2/http.h> #include "common.h" #include "Action.h" #include "Route.h" #include "WebSocket/SocketAction.h" #include "WebSocket/SocketRoute.h" #include "boost/filesystem.hpp" #include <map> #include <string> namespace Server { class Server { public: explicit Server(); void start(unsigned port); void route(const std::string& path, std::shared_ptr<Action> action, const HTTP_METHOD& = HTTP_METHOD::GET); void staticRoute(const std::string& path, const std::string& folder); void websocketRoute(const std::string&, std::shared_ptr<WebSocket::SocketAction>); void addExtensionType(const std::string&, const std::string&); bool staticRouteFileName(const std::string&, std::string&); std::shared_ptr<Response> getFileResponse(const std::string&); std::shared_ptr<Response> get404Response(); std::shared_ptr<Response> getHomePage(); void fileHomePage(const std::string&); void homeOn(const std::vector<std::string>&); void sendResponse(evhttp_request*, std::shared_ptr<Response>); static HTTP_METHOD convertEvCmd(const evhttp_cmd_type&); bool isReturnHome(const std::string& path); protected: std::map<std::string, std::string> _extensions; std::vector<Route> _routes; std::vector<WebSocket::SocketRoute> _socketRoutes; std::map<std::string, std::string> _staticRoutes; std::string fileHomePagePath; std::vector<std::string> homeRoutes; }; } // namespace Server#include "Frame.h" namespace Server { namespace WebSocket { Frame::Frame() {} } // namespace WebSocket } // namespace Server#include "FrameFactory.h" namespace Server { namespace WebSocket { Frame FrameFactory::closeFrame() { auto frame = Frame(); frame.fin = true; frame.opcode = Frame::OPCODE_CLOSE; frame.payload = ""; frame.mask = 0; return frame; } } // namespace WebSocket } // namespace Server#pragma once #include "Frame.h" namespace Server { namespace WebSocket { class FrameFactory { public: static Frame emptyFrame(); static Frame closeFrame(); static Frame pongFrame(); static Frame pingFrame(); }; } // namespace WebSocket } // namespace Server#pragma once #include "string" namespace Server { namespace WebSocket { class Frame { public: static const short OPCODE_CLOSE = 0x8; static const short OPCODE_TEXT = 0x1; static const short OPCODE_BINARY = 0x2; static const short OPCODE_PING = 0x9; static const short OPCODE_PONG = 0xA; Frame(); bool fin = true; bool rsv1 = false, rsv2 = false, rsv3 = false; char opcode = Frame::OPCODE_TEXT; bool mask = true; unsigned short baseLength = 0; unsigned long long extendedLength = 0; int bytesParsed = 0; char maskingKey[4] = {}; std::string payload = ""; }; } // namespace WebSocket } // namespace Server#include "FrameReader.h" namespace Server { namespace WebSocket { FrameReader::FrameReader() {} void FrameReader::clear() { this->_frameData = Frame(); this->_bytesRead = 0; } void FrameReader::read(char byte) { if (this->_bytesRead == 0) { this->readFirstByte(byte); } else if (this->_bytesRead == 1) { this->readSecondByte(byte); } else { if (auto lengthBytes = this->needParseLength()) { this->_frameData.extendedLength |= (byte << (lengthBytes - 1) LogFile.cpp LogFile.h LogsReader.cpp LogsReader.h MemoryInfo.cpp MemoryInfoData.cpp MemoryInfoData.h MemoryInfo.h style.log 8); } else if (auto lengthMask = this->needParseMasking()) { this->_frameData.maskingKey[4 - lengthMask] = byte; } else { if (this->_frameData.mask) { auto maskingOctet = this->_frameData.payload.size() % 4; this->_frameData.payload += byte ^ this->_frameData.maskingKey[maskingOctet]; } else { this->_frameData.payload += byte; } } } this->_bytesRead++; } Frame FrameReader::getFrameData() { return this->_frameData; } void FrameReader::readFirstByte(char byte) { std::bitset<8> bits(byte); this->_frameData.fin = bits[7]; this->_frameData.rsv1 = bits[6]; this->_frameData.rsv2 = bits[5]; this->_frameData.rsv3 = bits[4]; this->_frameData.opcode = bits[3] << 3 | bits[2] << 2 | bits[1] << 1 | bits[0]; } void FrameReader::readSecondByte(char byte) { std::bitset<8> bits(byte); this->_frameData.mask = bits[7]; this->_frameData.baseLength = bits[6] << 6 | bits[5] << 5 | bits[4] << 4 | bits[3] << 3 | bits[2] << 2 | bits[1] << 1 | bits[0]; } size_t FrameReader::needParseLength() { if (this->_frameData.baseLength == 126 && this->_bytesRead < 4) { return 4 - this->_bytesRead; } else if (this->_frameData.baseLength == 127 && this->_bytesRead < 10) { return 10 - this->_bytesRead; } return 0; } size_t FrameReader::needParseMasking() { if (!this->_frameData.mask) { return 0; } if (this->_frameData.baseLength < 126 && this->_bytesRead >= 2 && this->_bytesRead < 6) { return 6 - this->_bytesRead; } if (this->_frameData.baseLength == 126 && this->_bytesRead >= 4 && this->_bytesRead < 8) { return 8 - this->_bytesRead; } if (this->_frameData.baseLength == 127 && this->_bytesRead >= 10 && this->_bytesRead < 14) { return 14 - this->_bytesRead; } return 0; } bool FrameReader::isEndRead() { if (this->_bytesRead <= 2) { return false; } if (this->_frameData.baseLength < 126 && this->_frameData.payload.size() == this->_frameData.baseLength) { return true; } if (this->_frameData.baseLength > 125 && this->_frameData.payload.size() == this->_frameData.extendedLength) { return true; } } } // namespace WebSocket } // namespace Server#pragma once #include "Frame.h" #include "bitset" namespace Server { namespace WebSocket { class FrameReader { public: FrameReader(); void read(char byte); bool isEndRead(); void clear(); Frame getFrameData(); protected: Frame _frameData; size_t _bytesRead = 0; void readFirstByte(char byte); void readSecondByte(char byte); size_t needParseLength(); size_t needParseMasking(); }; } // namespace WebSocket } // namespace Server#include "FrameWriter.h" namespace Server { namespace WebSocket { FrameWriter::FrameWriter() { } FrameWriter::FrameWriter(const Frame& frame) { this->setFrame(frame); } void FrameWriter::setFrame(const Frame& frame) { this->_frameData = frame; } std::string FrameWriter::output() { std::string result = ""; result += (this->_frameData.fin << 7 | this->_frameData.rsv1 << 6 | this->_frameData.rsv2 << 5 | this->_frameData.rsv3 << 4 | this->_frameData.opcode); result += static_cast<char>(this->_frameData.baseLength & 0x7F); if (this->_frameData.baseLength == 126) { result += (this->_frameData.extendedLength >> 8) & 0xFF; result += this->_frameData.extendedLength & 0xFF; } else if (this->_frameData.baseLength == 127) { result += this->_frameData.extendedLength >> 56 & 0xFF; result += this->_frameData.extendedLength >> 48 & 0xFF; result += this->_frameData.extendedLength >> 40 & 0xFF; result += this->_frameData.extendedLength >> 32 & 0xFF; result += this->_frameData.extendedLength >> 24 & 0xFF; result += this->_frameData.extendedLength >> 16 & 0xFF; result += this->_frameData.extendedLength >> 8 & 0xFF; result += this->_frameData.extendedLength & 0xFF; } // if (this->_frameData.mask) { // result += this->_frameData.maskingKey[0]; // result += this->_frameData.maskingKey[1]; // result += this->_frameData.maskingKey[2]; // result += this->_frameData.maskingKey[3]; // } result += this->_frameData.payload; return result; } } // namespace WebSocket } // namespace Server#pragma once #include "Frame.h" #include "string" namespace Server { namespace WebSocket { class FrameWriter { public: FrameWriter(); FrameWriter(const Frame&); std::string output(); void setFrame(const Frame&); protected: Frame _frameData; }; } // namespace WebSocket } // namespace Server#pragma once namespace Server { namespace WebSocket { class SocketAction { }; } // namespace WebSocket } // namespace Server#include "SocketConnection.h" #include "FrameReader.h" namespace Server { namespace WebSocket { SocketConnection::SocketConnection(evhttp_connection* con) { this->_conn = con; this->_reader = std::make_shared<FrameReader>(); } evhttp_connection* SocketConnection::getConnection() { return this->_conn; } std::shared_ptr<FrameReader> SocketConnection::getFrameReader() { return this->_reader; } void SocketConnection::close() { // evhttp_connection_free(this->_conn); } } // namespace WebSocket } // namespace Server#include "FrameReader.h" #include <event2/http.h> #include <memory> namespace Server { namespace WebSocket { class SocketConnection { public: enum CONNECTION_STATE { CLOSED, CLOSING, OPENED }; SocketConnection(evhttp_connection*); CONNECTION_STATE state; evhttp_connection* getConnection(); std::shared_ptr<FrameReader> getFrameReader(); void close(); protected: evhttp_connection* _conn = nullptr; std::shared_ptr<FrameReader> _reader = nullptr; }; } // namespace WebSocket } // namespace Server#include "SocketRoute.h" namespace Server { namespace WebSocket { SocketRoute::SocketRoute(const std::string& path, std::shared_ptr<SocketAction> action) : _path(path) , _action(action) { } std::string SocketRoute::getPath() { return this->_path; } } // namespace WebSocket } // namespace Server#pragma once #include "memory" #include "string" #include "SocketAction.h" namespace Server { namespace WebSocket { class SocketRoute { public: SocketRoute(const std::string&, std::shared_ptr<SocketAction>); std::string exec(const std::string&); std::string getPath(); protected: std::shared_ptr<SocketAction> _action = nullptr; std::string _path = ""; }; } // namespace WebSocket } // namespace Server#include "LogFile.h" namespace Services { LogFile::LogFile(const std::string& path) : path(path) { this->processPath(); } void LogFile::processPath() { this->isValidLogFile = false; auto config = Common::Config::getInstance(); std::smatch match; auto path = fs::path(this->path); if (!fs::is_regular_file(path)) { return; } this->fileName = path.filename().string(); if (std::regex_match(this->fileName, match, config->logFileTemplateObj->regular)) { this->isValidLogFile = true; for (int i = 1; i < match.size(); i++) { auto paramName = config->logFileTemplateObj->params[i - 1]; if (paramName == "time") { this->time = match[i].str(); } else if (paramName == "level") { for (auto& logLevel : config->logLevels) { if (logLevel->key == match[i].str()) { this->level = logLevel; break; } } } } } if (this->level == nullptr) { // If not found level this->isValidLogFile = false; } } std::vector<nlohmann::json> LogFile::getMsgs() { std::vector<nlohmann::json> msgs; if (!this->isValidLogFile) { return msgs; } auto ifs = std::ifstream(this->path); auto content = std::string(std::istreambuf_iterator<char>(ifs), std::istreambuf_iterator<char>()); std::vector<std::string> stringMessages; boost::algorithm::split(stringMessages, content, boost::algorithm::is_any_of("\r\n")); for (auto& msg : stringMessages) { if (!msg.empty()) { msgs.push_back(nlohmann::json::parse(msg)); } } return msgs; } void to_json(nlohmann::json& j, const LogFile& logFile) { j = { { "time", logFile.time }, { "fileName", logFile.fileName }, { "level", *logFile.level } }; } void from_json(const nlohmann::json& j, LogFile& logFile) { logFile.time = j.at("time").get<std::string>(); logFile.fileName = j.at("fileName").get<std::string>(); auto jsonLevel = j.at("level").get<Common::LogLevel>(); auto c = Common::Config::getInstance(); for (auto& logLevel : c->logLevels) { if (jsonLevel.key == logLevel->key) { logFile.level = logLevel; break; } } } } // namespace Services #pragma once #include "../Common/Config.h" #include "./../json/json.hpp" #include "boost/algorithm/string.hpp" #include "boost/filesystem.hpp" #include <iostream> #include <string> #include <vector> namespace Services { namespace fs = boost::filesystem; class LogFile { public: LogFile(const std::string&); std::vector<nlohmann::json> getMsgs(); std::string path; std::shared_ptr<Common::LogLevel> level = nullptr; std::string time; std::string fileName; bool isValidLogFile = false; protected: void processPath(); }; void to_json(nlohmann::json& j, const LogFile&); void from_json(const nlohmann::json& j, LogFile&); } // namespace Services#include "LogsReader.h" #include <iostream> namespace Services { LogsReader::LogsReader(const std::string& path, const std::string& ext) : path(path) , ext(ext) {} std::vector<LogFile> LogsReader::getLogsFiles() { std::vector<LogFile> files; for (boost::filesystem::directory_entry& file : boost::filesystem::directory_iterator(this->path)) { if (!fs::is_regular_file(file)) { continue; } auto fileName = file.path().native(); auto extension = file.path().extension().string(); if (extension == this->ext) { auto f = LogFile(fileName); if (f.isValidLogFile) { files.emplace_back(f); } } } return files; } } // namespace Services#pragma once #include "LogFile.h" #include "boost/filesystem.hpp" #include <string> #include <vector> namespace fs = boost::filesystem; namespace Services { class LogsReader { public: LogsReader(const std::string& path, const std::string& ext); std::vector<LogFile> getLogsFiles(); protected: std::string path; std::string ext; }; } // namespace Services#include "MemoryInfo.h" namespace Services { MemoryInfo::MemoryInfo() { struct sysinfo info; sysinfo(&info); this->allMemory = info.totalram; this->freeMemory = info.freeram; this->usageMemory = this->allMemory - this->freeMemory; } void to_json(nlohmann::json& j, const MemoryInfo& m) { j = nlohmann::json{ { "allMemory", m.allMemory }, { "freeMemory", m.freeMemory }, { "usageMemory", m.usageMemory } }; } void from_json(const nlohmann::json& j, MemoryInfo& m) { m.usageMemory = j.at("usageMemory").get<size_t>(); m.freeMemory = j.at("freeMemory").get<size_t>(); m.usageMemory = j.at("usageMemory").get<size_t>(); } } // namespace Services#include "MemoryInfoData.h" #pragma once #include "./MemoryInfo.h" #include <cstdio> #include <map> #include <time.h> namespace Services { class MemoryInfoData { public: MemoryInfoData() { } protected: std::map<size_t, std::shared_ptr<MemoryInfo>> data; }; } // namespace Services #pragma once #include "./../json/json.hpp" #include <cstdio> #include <sys/sysinfo.h> namespace Services { class MemoryInfo { public: MemoryInfo(); size_t allMemory; size_t freeMemory; size_t usageMemory; }; void to_json(nlohmann::json& j, const MemoryInfo&); void from_json(const nlohmann::json& j, MemoryInfo&); } // namespace Services
